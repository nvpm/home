*flux.txt*			      `A parser for the flux markup language`

==============================================================================
CONTENTS                                          *flux*
INTRODUCTION		      			  |flux_intro|
THE FLUX SYNTAX 		                  |flux_syntax|
SYNTAX ELEMENTS 		                  |flux_elements|
SYNTAX CONFIGURATION                              |flux_syntax_config|
THE LEXICON CONFIGURATION                         |flux_lexicon|
THE FLUX DATA STRUCTURE                           |flux_data_structure|
DATA STRUCTURE EXAMPLE                            |flux_data_example|

INTRODUCTION                                                   *flux_intro*

Note: In order to properly understand the usage of this plugin, the reader may
      need to go back and forth in this document.

The flux plugin was created to provide a parsing mechanism for the plugins
under the nvpm plugin pack. Not all plugins will use it though, but those
that do, will rely heavily on it.

This plugin deals with a markup language that describes a tree-like structure
given a particular context. The resulting of the parsing will be a tree data
structure in a form of a dictionary.

THE FLUX SYNTAX                                               *flux_syntax*

The syntax is composed of pre-defined keyword elements, which will define the
different node leves in the tree. Much like one would write different levels
of subjects on a piece of paper. Examples later!

The tree data-structure, returned by flux, will explore the following
concepts:

- `leaf node` is the node at the end of a tree. They will not have any
  children branching from them.

- `tree node` is the node that has children, which can be either a leaf
  node or yet another tree node.

- `root node` is the node at the base of the tree (where it all begins).
  Note: in this case the root node is in fact a tree node

SYNTAX ELEMENTS	      				              *flux_elements*

The following is a general form of each valid line of a flux file.

	   ╭──────────────────────────────────────────────╮
	   │ modifier keyword <kname> [:=] <kvalue> [#{}] │
	   │    m        k       n    s        v      c   │
	   ╰──────────────────────────────────────────────╯
	   m: the element modifier
	   k: the keyword itself (case insensitive)
	   n: the name for that keyword
	   s: the separator
	   v: the value for that keyword
	   c: the comments (# ...)

And the best way to explain the usage is with a practical example. Say we want
to describe the placement of files in a project. For the sake of this example,
let's consider a simple C project, with 3 files, say: main.c, main.h, and
Makefile. In this case, a valid flux file used by the |arbo| plugin is:

            - project.flux  -
	   ╭───────────────────────╮
	   │  file main.c          │
	   │  file main.h          │
	   │  file make: Makefile  │
	   ╰───────────────────────╯

in this case the file 'Makefile' was given a name (make). This will be usefull
for the visual feedback of the |arbo| plugin, and possibly others too.

SYNTAX CONFIGURATION                                 *flux_syntax_config*

The configuration of flux is not done by global variables read at startup.
Flux is a call on-demand kinda plugin, which means its only called by other
plugins when they need it.

Each client plugin will pass a dictionary configuration variable to flux at
each call. This dictionary should contain three keys: file, syntax, and
lexicon.

- `file`    : is the file to be parsed
- `syntax`  : the syntax used (default 'plain')
- `lexicon` : the list of keywords recognized by flux

  This variable describes not only the words, but order of precedence in which
  a node is to be parsed. In other words, it describes which elements will be
  contained in which.

  This order is defined by a comma-separated string. For example:

  ```vimscript
    let conf = {}
    let conf.file = 'foobar.flux'
    let conf.lexicon = 'foo,bar'
	   ...
  ```

  here "foo" elements will contain a list of "bar" element, and never the other
  way around.

                                                             *flux_number_type*
  Also, this defines the number type of an element. which is the order in which
  the word appear in the lexicon: 1:foo, 2:bar. In fact, the same example
  above could also be done as follows:

  ```vimscript
    let conf = {}
    let conf.file = 'foobar.flux'
    let conf.lexicon = [['foo'],['bar']]
	   ...
  ```

  which is the form flux actually uses. Note: the 0 number type will be used
  for the flux file itself.

THE LEXICON CONFIGURATION                                      *flux_lexicon*

The main syntax for the lexicon is:

- `string format`

    "KW11 KW12 ... KW1n , ... , KWm1 KWm2 ... KWmn"
	     |	  |     |           |
	     |	  v     v           |
	     |	   comma            |
	     |                            |
	     +-> number type: 1           +-> number type: m

- `list format`

    [["KW11","KW12",...,"KW1n"],...,["KWm1","KWm2",...,"KWmn"]]
		  1                               m

where {KWij} matches the following regex [a-z0-9_].

The following are valid forms for the lexicon key:

  ```vimscript
  let conf = {}
  let conf.lexicon = 'workspace , tab folder, buff file'
  let conf.lexicon = [['workspace'],['tab','folder'],['buff','file']]
	 ...              " 1             2                 3
  ```

Note: The only reason why the lexicon field exists is to avoid writing a spell
checker for the language. This way any words that don't belong or even typos
will just be ignored without giving an error message. This behaviour becomes
clearer when using the |arbo| plugin.

To further explain the syntax,

                                 ||   - foobar.flux -
```vimscript                     ||   ╭──────────────────────╮
  let conf = {}                  ||   │  foo foo-01 : val1   │
  let conf.file = 'foobar.flux'  ||   │    bar b01 : bar 1   │
  let conf.lexicon = 'foo,bar'   ||   │    bar b02 = bar 2   │
                                 ||   │                      │
  let data = flux#flux(conf)     ||   │  foo foo-02 : val2   │
```                              ||   │    bar code          │
                                 ||   ╰──────────────────────╯

in this case, only the words "foo" and "bar" will be accepted as valid
keywords in the flux file "main.flux". Moreover, note that foo and bar are
separeted by comma. This means that foo takes precedence over bar, in the
context of a tree.

THE FLUX DATA STRUCTURE                            *flux_data_structure*

The example above shows a call to the main flux function "flux#flux(...)",
which returns the tree data-structure described in the flux file.

Each node of the tree, as well as its subtrees, will be in a form of a
dictionary that may contain the following keys: file, info, meta, and list.

- `file`:                                                *flux_data_file*
    type: string

    Stores the path to the flux file used when supplying the configuration
    variable to flux#flux.

    This is only used in the root node of the tree

- `info`:                                                *flux_data_info*
    type: dictionary
    keys: keyw, name, and info

    Composed of the information described in a flux element. Its fields are:
    keyw, name, and info. Say we have an element that decribes a file node:

		    ╭────────────────────────────────────╮
		    │                                    │
		    │ file main : main.c # the main file │
		    │                                    │
		    ╰────────────────────────────────────╯

    in this case, its "info" dictionary field will be

	      ╭───────────────────────────────────────────────╮
	      │                                               │
	      │ {'keyw':'file','name':'main','info':'main.c'} │
	      │                                               │
	      ╰───────────────────────────────────────────────╯

- `meta`:                                                *flux_data_meta*
    type: dictionary
    keys: type, leng, and indx

    Composed of the meta information regarding the list (|flux_data_list|) of
    subnodes (children), in a given node.

    Consider the same example in |flux_data_info|, and that the lexicon use is
    of the form "tab,file". Then, the resulting meta field will be something
    like this:

		   ╭──────────────────────────────╮
		   │                              │
		   │ {'type':2,'leng':3,'indx':0} │
		   │                              │
		   ╰──────────────────────────────╯

    this means the list field has three elements of type 2 (file elements),
    and it's currently placed at the first file element.


- `list`:                                                *flux_data_list*
    type: list
    items: dictionary nodes

    Composed of the subnodes in the tree a.k.a children. Its length, type of
    nodes, and current index are described in |flux_data_meta

DATA STRUCTURE EXAMPLE                                *flux_data_example*

  Consider the following scenario.

  1) the configuration fed to flux#flux is of the form:

	╭────────────────────────────────────────────────────────────╮
	│                                                            │
	│ {'file':'code.flux','lexicon':'workspace,tab,buffer file'} │
	│                                                            │
	╰────────────────────────────────────────────────────────────╯

  2) the content flux file "code.flux" is:

  ╭───────────────────────╮
  │ WORKSPACE code        │
  │   tab root            │
  │     file main.c       │
  │   tab lib : src       │
  │     buffer lib.c      │
  │     buffer lib.h      │
  │                       │
  │ WORKSPACE meta = meta │
  │   buffer install.sh   │
  │                       │
  ╰───────────────────────╯

{ file: test/flux/case.flux,
  meta: {leng: 2, type: 1, indx : 0},
  list: [
    {info: {keyw: "WORKSPACE", info: ""    , name: "code"},
     meta: {leng: 2, type: 2, indx : 0},
     list: [
      {info: {keyw: "tab", info: ""   , name: "root"},
       meta: {leng: 1, type: 3, indx: 0},
       list: [
         {info: {keyw: "file", info: "main.c", name: "main.c" }}
       ],
      },
      {info: {keyw: "tab", info: "src", name: "lib"},
        meta: {leng: 2, type: 3, indx: 0}
        list: [
          {info: {keyw: "buffer", info: "src/lib.c", name: "lib.c"}},
          {info: {keyw: "buffer", info: "src/lib.h", name: "lib.h"}}
        ],
      }
    ],
    },
    {info: {keyw: "WORKSPACE", info: "meta", name: "meta"},
     meta: {leng: 1, type: 3, indx: 0},
     list: [
      {info: {keyw: "buffer", info: "meta/install.sh", name: "install.sh"}},
     ],
    }],
}

vim:tw=78:ts=8:noet:ft=help:norl:
