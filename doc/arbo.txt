*arbo.txt*			      `A parser for the arbo markup language`

CONTENTS                                          *arbo*

Introduction		      			  |arbo-intro|
The Arbo Syntax 		                  |arbo-syntax|
Syntax Configuration                              |arbo-syntax-config|
The Lexicon Configuration                         |arbo-lexicon|
The Trim Mechanism                                |arbo-tree-trimming|
The Arbo Data Structure                           |arbo-data-structure|
Data Structure Example                            |arbo-data-example|

INTRODUCTION                                                   *arbo-intro*

Note: In order to properly understand the usage of this plugin, the reader may
      need to go back and forth in this document.

The nvpm/arbo plugin was created with the purpose of providing a parsing
mechanism for the `arbo` markup language, which is defined in this document.

This language offers a simplified way to obtain a tree data-structure from a
human-readable file, following the `arbo` syntax. However, do not get your
hopes up thinking this language will rival other languages such as YAML, JSON
or even XML. No, that wasn't the point here!

The point was to provide a markup language that can be used inside the scope
of the nvpm/* plugins. Theses plugins will then have a mechanism to store meta
data, and other important information, in various contexts.

Note: for now, only the nvpm/nvpm plugins uses it, but other nvpm/* plugins
will too in the future.

And you may be wondering: why not just use languages such as YAML or XML?
Well, simply because of the following reasons:

1) to avoid depending on other projects;
2) to avoid bloatware:

   Even if there is an YAML or XML plugin developed in Vimscrip, not all
   functionalities features of such languages will be used by the nvpm/*
   plugins.

3) the conveniences that come from reason (1):

  If a nvpm/* plugin needs the arbo language to have a specific feature, we
  won't need to wait for those languages to evolve. We can simply develop it
  in Vimscript and be done with it.

Also, although the arbo language can be used in various contexts, it's features
were thought to be used in the nvpm/* plugins. This also has the benefit of
keeping the language as clean as possible, by only having what the nvpm/*
plugins need, as opposed to the huge set of contexts that YAML or XML can be
used. Again, reason (2).

As we will see, the arbo language works in a different manner. No spell check
mechanisms were developed in the nvpm/arbo plugin. Instead, the user (human or
plugin) needs to first define what is called a `lexicon`, which is the set of
"allowed" keywords in the arbo file.

This was done for the sake simplicity. This way, any keywords that don't belong
in the lexicon will simply be ignored by the parsing routines.

THE ARBO SYNTAX                                               *arbo-syntax*

The syntax for each line of an arbo file is composed of pre-defined keywords
followed by the information for that keyword.

As mentioned before, those keywords are listed in the lexicon, which is the list
of allowed keywords. In this way, the arbo parser will only recognize lines
that begin with those keywords and ignore all other lines that start with
other words that don't belong.
======================
* The Configuration Dictionary                      *arbo-config-dict*

It's unlikely that an end user will ever need to directly use the arbo plugin,
since it was meant to be used by other applications. That's why it does not
provide any user commands. Instead, it works by function call. And despite
having many functions, a single function call is enough to parse an arbo file.

This function is called `arbo#arbo(...)`, and it takes a single configuration
dictionary. For now, the following are the allowed fields of this dictionary:

- `file`   : the full path to the arbo file to be parsed;
- `lexicon`: the list of allowed keywords as mentioned before;
- `homing` : the flag that allows for the homing mechanism, used by the
	   nvpm/nvpm plugin;
- `fixtree`: the flag that tells arbo to fix user mistakes in the arbo file.
- `syntax` : an alias that sets a bundle of options

The following is a complete example:
>
  ...
  let arboconf = {}
  let arboconf.file = 'example.arbo'
  let arboconf.home = 0
  let arboconf.fixt = 0
  let arboconf.lexicon = ['foo','bar']

  let arbodata = arbo#arbo(arboconf)
  ...

The following is the explanation of each element in the example above.
======================
1) the lexicon:                                  *arbo-config-lexicon*

This field defines an order of hierarchy in which the keywords should be
interpreted. In the example above, "foo" keywords will have precedence over
"bar" keywords, in the arbo file. This means that the "bar" entries are
interpreted as children of the "foo" ones. This will become clear later!

Also, there are two ways you can write a lexicon fields: in either string or
list formats. The following is the general syntax for both ways:

- string format >

  "KW11 KW12 ... KW1n , ... , KWm1 KWm2 ... KWmp"
	      |	      |     |            |
	      |	      v     v            |
	      |	       comma             |
	      |                          |
	      +-> number type: 1         +-> number type: m
		  length: n                  length: p
<
- list format >

  [["KW11","KW12",...,"KW1n"],...,["KWm1","KWm2",...,"KWmp"]]
		  1                               m
<
where {KWij} matches the following regex [a-z0-9_].

Note: the string format was created for convenience as we will see later.
======================
1.1) the number type (NT):                  *arbo-config-lexicon-number-type*

This concept allows the client plugins to have a numeric way of knowing the
order of hierarchy in which the keywords are defined. In mathematical terms,
the number type a keyword is defined as follows:
>
  For every keyword {KWij}, where 1<=i and i<=n => Number type = i
======================
1.2) lexicon examples:                         *arbo-config-lexicon-examples*

The following is the default lexicon used by the nvpm/nvpm plugin:

  In string format >
  ```vimscript
  let nvpm = {}
  let nvpm.lexicon  = ""
  let nvpm.lexicon .= ",project scheme layout root"      "number type: 1
  let nvpm.lexicon .= ",workspace archive trunk"         "number type: 2
  let nvpm.lexicon .= ",tab folder shelf package branch" "number type: 3
  let nvpm.lexicon .= ",file buffer path entry leaf"     "number type: 4
  ```
<
  In list format >
  ```vimscript
  let nvpm = {}
  let nvpm.lexicon  = []
  let nvpm.lexicon += ["project","scheme","layout","root"]        "NT: 1
  let nvpm.lexicon += ["workspace","archive","trunk"]             "NT: 2
  let nvpm.lexicon += ["tab","folder","shelf","package","branch"] "NT: 3
  let nvpm.lexicon += ["file","buffer","path","entry","leaf"]     "NT: 4

  echo nvpm.lexicon[0][2] " echoes "scheme"
  echo nvpm.lexicon[2][3] " echoes "shelf"
  ```
<
The following, is lexicon for countries, states, and cities:
>
  ```vimscript
  let places = {}
  let places.lexicon = "country, state, city"
  let places.lexicon = ["country","state","city"]
  ```                      
<
Another for events:
>
  ```vimscript
  let events = {}
  let events.lexicon = "year, month, event"
  ```                      
<
Notes: 
  1) any number of leading or trailing or in between spaces or commas will be 
     ignored in the string format.

  2) the last element in the lexicon list is always called leaf keywords,
     which will relate to the leaf nodes of the tree data-structure returned
     by `arbo#arbo(...)`.
     
  3) if you consider 0 <= i < len(lexicon), then the number type of
  lexicon[i][j] equals i+1.
======================
2) the file:                                  *arbo-config-file*

The file filds is self explanatory. Is the path to the file to be parsed. It
can be any ASCII file, with any extension, but at least in the nvpm/* plugins,
they'll have `*.arbo` extensions.

For now, only files can be parsed.
======================
2.1) the arbo file syntax:                          *arbo-file-syntax*

In order to understand the `home` and `fixt` fields, the syntax for arbo files 
has to be explained. The following is a general form of a valid line in an 
arbo file:
>
  ╭───────────────────────────────────────╮
  │ [modifier] keyword info  [,] [#{}]]   │
  │      m        k      i    e    c      │
  ╰───────────────────────────────────────╯
  m: the element modifier
     For now it's just the trimming mechanism.

  k: the keyword itself (case insensitive)
     A keyword defined in the lexicon. It has to match the pattern [a-zA-Z0-9_].

  i: the information held by that keyword entry
  e: the end-of-line character
  c: in-line comments

And the following are examples of arbo files with their respective lexicon
lists:
>
    lexicon: "tab,file"        lexicon: "year, event"            
    ╭─────────────────╮        ╭──────────────────────────────╮ 
    │           ...   │        │  year 1912                   │ 
    │  TAB main       │        │    event Titanic's shipwreck │
    │    file main.c  │        │  year 1914                   │
    │   -file main.h  │        │    event Start of 1st WW     │
    │                 │        │  year 1918                   │
    │ -TAB math       │        │    event End of 1st WW       │
    │    file math.c  │        │  year 1939                   │
    │    file math.h  │        │    event Start of 2nd WW     │
    ╰─────────────────╯        │               ...            │
                               ╰──────────────────────────────╯
			  
		 lexicon: "country, city"         		     
		 ╭────────────────────────╮
		 │  country USA {         │
		 │    city New York       │
		 │    city Los Angeles    │
		 │    city Detroit        │
		 │  }                     │
		 │  country Brazil {      │
		 │    city São Paulo      │
		 │    city Rio de Janeiro │
		 │    city Florianópolis  │
		 │  }                     │       		   
		 ╰────────────────────────╯ 
<
Note: the indentation shown above is optional.


vim:tw=78:ts=8:noet:ft=help:norl:
